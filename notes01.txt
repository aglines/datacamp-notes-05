

COURSE DATA MANIPULATION W PANDAS

1 Transforming DataFrames
fundamental manipulations, including sorting rows, subsetting, and adding new columns.

###### DataFrames - Inspecting 
pandas built on numpy - multidim array ojbects for easy data manip,
 & matplolib has data viz abilites.  rectangular data = tabular data.  Pandas IS designed to work w rectangular data.

---------------------------------------
EXAMINE data: 

df.head()
    first few rows shows
df.info()
    shows all cols, non-null count of rows, and datatype
df.shape
    number rows and number cos
df.describe()
    gives some summary stats - count, mean, stddev, min, max..
df.values
    shows all the values in a 2D numpy array
df.columns
    column names
df.index 
    shows row numbers or names

----------------------------------------------------------
Sorting and subsetting

sort values
df.sort_values("columnName")
    default is ascending

change sorting order
df.sort_values("colName", ascending=False)

sort by multiple values
df.sort_values(["colToSortFirst", "colSortSecond"])

df sorting - diff directions
df.sort_values(["colToSortFirst", "colSortSecond"], ascending=[True,False])

see just one dataframe col?
df["colName"]

see multiple dataframe cols?
df[["colName1", "colName2"] ]

subset rows using condition
df["colName"] > 50,

subset on a condition?
df[df["colName"] > 50 ]

subset on multiple conditions?
is_over50["size"] > 50
is_MainStreet["addr"] == "MainStreet"
df[is_over50 & is_MainStreet]

subset on mult conditions in one line
df[ (df["people"] < 1000) & (df["region"] == "Pacific") ] 

subset on different values of a single column?
is_Red_or_Gray = df["color"].isin(["Red", "Gray"])
df[is_Red_or_Gray]

add new columns from existing
df["sizeMeters"] = df["sizeCm"] / 100

---------------------------------------------------------------
#### CHAP 2 SUMMARY STATS

df["height"].mean()
min, max
median, mode
var (variance), std, sum

** aggregate method - combine any you want into a function
def pct30(column):
    return column.quantile(0.3)
dogs["height"].agg(pct30)

agg method on multiple col
.. (as above)
dogs[["height", "weight"]].agg(pct30)

multiple aggs too -- 
def pct40(column):
    return column.quantile(0.4)
dogs[["height", "weight"]].agg([pct30, pct40])

cumulative sum
dogs["height"].cumsum()
ditto - cummax(), cummin(), cumprod()
they all return a df, not a number

--------------------------------------------------------------
counting

drop duplicates inside a single column
df.drop_duplicates(subset="colName")

drop duplicate pairs/groups within multiple columns
df.drop_duplicates(subset=["col1", "col2"])

count appearances in a column, ie categorical variables
uniques.df["col1"].value_counts()

and sort them as counting
uniques.df["col1"].value_counts(sort=True)
here sort is descending apparently

normalize to turn counts into the proportion of total
uniques.df["col1"].value_counts(normalize=True)
--------------------------------------------------------------
grouped summary stats

do math on multiple subsets at once
group by the color variable, select the weight col, & get the mean:
dogs.groupby("color")["weight"].mean()

instead of
    dogs[dogs["color"] == "red"]["weight"].mean()
    dogs[dogs["color"] == "blue"]["weight"].mean()
    ...

use agg method with grouped
dogs.groupby("color")["weight"].agg([mean, min, sum])

group by multiple everything
dogs.groupby(["color","breed"])["weight","age"].agg([max, min])


--------------------------------------------------------------
grouped summary stats w pivot table instead of groupby

    groupby was df.groupby("color")["breed"]
pivot table: values is selected col, index is col to group by
df.pivot_table(values="breed", index="color")

Note : pivot table uses the MEAN value for e group

use a diff summary stat? use "aggfunc" jfc
df.pivot_table(values="breed", index="color", aggfunc=np.median)

multi summ stats
df.pivot_table(values="breed", index="color", aggfunc=[np.median, np.mean])

PIVOT like groupby can use multi variables:
    df.groupby(["color","breed"])["age"].mean()
df.pivot_table(values="age", index="color", columns="breed")
    here the 1st col chosen becomes "values", 2nd is "columns"

fill in missing vals or NaNs 
df.pivot_table(values="age", index="color", columns="breed", fill_value=0)

margins=True :  
last column & row has mean of all values, not counting NaNs ... but it's... a sum?
df.pivot_table(values="age", index="color", columns="breed", fill_value=0, margins=True)

---------------------------------------------------------------------------------------------
######## CHAP 3 Slicing and Indexing DataFrames
Dataframes have 3 parts - a numpy array for data, & 2 indexes for row and col labels

review: 
    df.columns gives an Index object of col names
    df.index gives an Index object of row numbers

move a col from body of df to the Index
df.set_index("colName")
note - index values are now left-aligned  not right-aligned

move data back
df.reset_index()

drop the index entirely, reverting it to numbers
df.reset_index(drop=True)
    whatever col had been moved to Index, is now entirely gone

indexes make subsetting easier .loc
df.loc[["name1", "name2"]]

    this is hard to do without index names
df[df["name1"].isin(["Mod","Nod"])]

- index values need not be unique

multiple indexes OK - multilevel or hierarchical
df.set_index(["name", "age"])
the inside one is the 2nd one set
data forms groups first for outer index then inner

subset rows of outer index - pass a list to loc with just outer index
df.loc[["addr", "phone"]]

subset rows at inner index - pass a list of BOTH indexes to loc
df.loc[[ ("addr", "local"), ("phone", "mobile")  ]]
resulting rows must match both indexes - just matching one index wont be returned


sort by index
df.sort_index()
    sorts all indexes from outer to inner in ascending

sort by index multiple
df.sort_index( level=["addr", "phone"], ascending=[True,False])

downsides? stores data in 2 ways means 2 syntaxes


------------------------------------------------------------------------------------------------
SLICING 

sort index before slicing!
dfSorted = df.sort_index()

set and sort index same time
dfSorted = df.set_index(["animal","breed"]).sort_index()

to slice rows at outer index - 
dfSorted.loc["bird":"cat"]

same technique wont work on inner index - 
dfSorted.loc["parakeet":"Siamese"]
    returns empty df but NO ERROR

to slice rows at inner index - pass values as tuples
dfSorted.loc[("bird","parakeet") : ("cat","Siamese")]

slice dataframe columns with loc - keep all rows
dfSorted.loc[:, "addr":"zip"]

slice rows and cols at same time incl multi-index:
dfSorted.loc[ ("country","city"):("population","subpop") , "name":"year" ]

slicing by dates - you can use just the year insetad of the whole string

iloc - does NOT include final value, 
loc DOES include final value











Slicing and subsetting with .loc and .iloc

Slicing index values

Slicing in both directions

Slicing time series

Subsetting by row/column number

Working with pivot tables

Pivot temperature by city and year

Subsetting pivot tables

Calculating on a pivot table


4
Creating and Visualizing DataFrames

Learn to visualize the contents of your DataFrames, handle missing data values, and import data from and export data to CSV files.

Visualizing your data

Which avocado size is most popular?

Changes in sales over time

Avocado supply and demand

Price of conventional vs. organic avocados

Missing values

Finding missing values

Removing missing values

Replacing missing values

Creating DataFrames

List of dictionaries

Dictionary of lists

Reading and writing CSVs

CSV to DataFrame

DataFrame to CSV

Wrap-up